<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Space Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            user-select: none;
            z-index: 10;
        }
        .time-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 30px;
            font-size: 14px;
            user-select: none;
            z-index: 10;
        }
        .time-btn {
            cursor: pointer;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            transition: background 0.2s;
        }
        .time-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .time-btn.active {
            background: rgba(0, 150, 255, 0.5);
        }
        .simulation-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            user-select: none;
            z-index: 10;
        }
        .planet-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 30, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            color: white;
            z-index: 100;
            width: 320px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
        }
        .editor-title {
            margin-top: 0;
            text-align: center;
            color: #3498db;
            font-size: 18px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .editor-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        .editor-label {
            width: 100px;
            flex-shrink: 0;
        }
        .editor-value {
            flex-grow: 1;
        }
        input[type="range"] {
            width: 100%;
            background: #333;
            height: 8px;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 8px;
            background: #3498db;
            cursor: pointer;
        }
        input[type="color"] {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border: none;
            background: none;
            cursor: pointer;
        }
        input[type="number"] {
            background: rgba(50, 50, 70, 0.8);
            border: 1px solid #444;
            color: white;
            padding: 5px;
            width: 60px;
            border-radius: 4px;
        }
        .editor-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .editor-btn {
            background: #2980b9;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: bold;
        }
        .editor-btn:hover {
            background: #3498db;
        }
        .editor-btn.cancel {
            background: #7f8c8d;
        }
        .editor-btn.cancel:hover {
            background: #95a5a6;
        }
        .editor-btn.drag {
            background: #d35400;
        }
        .editor-btn.drag:hover {
            background: #e67e22;
        }
        .editor-btn.drag.active {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
        }
        .velocity-visualizer {
            width: 100%;
            height: 100px;
            background-color: rgba(40, 40, 60, 0.5);
            border-radius: 8px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }
        .velocity-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: 0 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 12px solid #3498db;
        }
        .velocity-planet {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: #e74c3c;
            border-radius: 50%;
            transform: translate(-10px, -10px);
        }
        .velocity-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        /* Pause Menu Styles */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .pause-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .pause-menu {
            background-color: rgba(15, 22, 36, 0.95);
            border-radius: 12px;
            padding: 40px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: white;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .pause-overlay.active .pause-menu {
            transform: translateY(0);
            opacity: 1;
        }
        .pause-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }
        .pause-title {
            font-size: 32px;
            font-weight: 700;
            margin: 0;
            color: #60a5fa;
            letter-spacing: 1px;
        }
        .pause-subtitle {
            color: rgba(255, 255, 255, 0.6);
            margin: 5px 0 25px 0;
            font-size: 16px;
        }
        .keybind-section {
            margin-bottom: 20px;
        }
        .keybind-title {
            font-size: 18px;
            color: #60a5fa;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .keybind-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .keybind-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: rgba(30, 41, 59, 0.7);
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .keybind-item:hover {
            background-color: rgba(30, 41, 59, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .keybind-item.listening {
            background-color: rgba(59, 130, 246, 0.2);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        .keybind-action {
            color: #f8fafc;
        }
        .keybind-key {
            background-color: rgba(20, 30, 45, 0.8);
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
        }
        .pause-menu-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .pause-btn {
            background-color: rgba(59, 130, 246, 0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pause-btn.primary {
            background-color: #3b82f6;
        }
        .pause-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .pause-btn.primary:hover {
            background-color: #60a5fa;
        }
        .pause-btn-icon {
            font-size: 18px;
        }
        .pause-info {
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
        }
        .pause-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(15, 22, 36, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 30px;
            display: none;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        .pause-indicator.active {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pause-indicator-icon {
            width: 8px;
            height: 12px;
            background-color: #60a5fa;
            margin-right: 2px;
            border-radius: 2px;
        }
        .pause-indicator-text {
            color: #60a5fa;
        }
        @media (max-width: 768px) {
            .keybind-grid {
                grid-template-columns: 1fr;
            }
            .pause-menu {
                padding: 20px;
            }
            .pause-title {
                font-size: 24px;
            }
        }
        @media (max-width: 600px) {
            .controls, .time-controls, .simulation-info {
                font-size: 12px;
                padding: 5px;
            }
            .planet-editor {
                width: 90%;
                max-width: 320px;
                padding: 15px;
            }
            .editor-row {
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <canvas id="spaceCanvas"></canvas>
    <div class="controls">
        <p><strong>Space Simulator Controls:</strong></p>
        <p>Press <strong>N</strong> to create a new planet at cursor position</p>
        <p>Hover over a planet and press <strong>D</strong> to delete it</p>
        <p>Press <strong>Q</strong> to simulate planet paths</p>
        <p>Press <strong>E</strong> to edit selected planet</p>
        <p>Press <strong>P</strong> to pause and configure</p>
        <p><strong>Mouse wheel</strong> to zoom in/out</p>
        <p><strong>Drag</strong> to pan the view</p>
    </div>
    
    <div class="simulation-info" id="simulationInfo" style="display: none;">
        <p><strong>Simulating paths...</strong></p>
        <div id="simulationProgress">0%</div>
    </div>
    
    <div class="time-controls">
        <div class="time-btn active" data-speed="8">0.25x</div>
        <div class="time-btn" data-speed="16">0.5x</div>
        <div class="time-btn" data-speed="32">1x</div>
        <div class="time-btn" data-speed="64">2x</div>
        <div class="time-btn" data-speed="128">4x</div>
        <div class="time-btn" data-speed="256">8x</div>
    </div>

    <div class="pause-indicator" id="pauseIndicator">
        <div class="pause-indicator-icon"></div>
        <div class="pause-indicator-icon"></div>
        <div class="pause-indicator-text">PAUSED</div>
    </div>

    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-menu">
            <div class="pause-header">
                <h1 class="pause-title">Space Simulator</h1>
            </div>
            
            <p class="pause-subtitle">Simulation paused. Configure your controls below.</p>
            
            <div class="keybind-section">
                <h2 class="keybind-title">Planet Controls</h2>
                <div class="keybind-grid">
                    <div class="keybind-item" data-action="createPlanet">
                        <div class="keybind-action">Create Planet</div>
                        <div class="keybind-key" id="createPlanetKey">N</div>
                    </div>
                    <div class="keybind-item" data-action="deletePlanet">
                        <div class="keybind-action">Delete Planet</div>
                        <div class="keybind-key" id="deletePlanetKey">D</div>
                    </div>
                    <div class="keybind-item" data-action="editPlanet">
                        <div class="keybind-action">Edit Planet</div>
                        <div class="keybind-key" id="editPlanetKey">E</div>
                    </div>
                    <div class="keybind-item" data-action="simulatePaths">
                        <div class="keybind-action">Simulate Paths</div>
                        <div class="keybind-key" id="simulatePathsKey">Q</div>
                    </div>
                </div>
            </div>
            
            <div class="keybind-section">
                <h2 class="keybind-title">System Controls</h2>
                <div class="keybind-grid">
                    <div class="keybind-item" data-action="togglePause">
                        <div class="keybind-action">Pause/Resume</div>
                        <div class="keybind-key" id="togglePauseKey">P</div>
                    </div>
                    <div class="keybind-item" data-action="resetCamera">
                        <div class="keybind-action">Reset Camera</div>
                        <div class="keybind-key" id="resetCameraKey">R</div>
                    </div>
                </div>
            </div>
            
            <div class="pause-menu-footer">
                <button class="pause-btn" id="resetKeysBtn">
                    <span class="pause-btn-icon">↺</span> Reset Keys
                </button>
                <button class="pause-btn primary" id="resumeBtn">
                    <span class="pause-btn-icon">▶</span> Resume
                </button>
            </div>
            
            <p class="pause-info">Click on any control to rebind it</p>
        </div>
    </div>

    <div class="planet-editor" id="planetEditor">
        <h3 class="editor-title">Planet Editor</h3>
        
        <div class="editor-row">
            <div class="editor-label">Size:</div>
            <div class="editor-value">
                <input type="range" id="planetSize" min="10" max="50" value="20">
            </div>
        </div>
        
        <div class="editor-row">
            <div class="editor-label">Mass Factor:</div>
            <div class="editor-value">
                <input type="range" id="planetMass" min="0.1" max="5" value="1" step="0.1">
            </div>
        </div>
        
        <div class="editor-row">
            <div class="editor-label">Color:</div>
            <div class="editor-value">
                <input type="color" id="planetColor" value="#FF5733">
            </div>
        </div>
        
        <div class="editor-row">
            <div class="editor-label">Velocity:</div>
            <div class="editor-value">
                <div class="velocity-visualizer">
                    <div class="velocity-grid"></div>
                    <div class="velocity-planet" id="velocityPlanet"></div>
                    <div class="velocity-arrow" id="velocityArrow"></div>
                </div>
            </div>
        </div>
        
        <div class="editor-row">
            <div class="editor-label">Speed:</div>
            <div class="editor-value">
                <input type="number" id="speedValue" min="0" max="10" value="1" step="0.1">
            </div>
        </div>
        
        <div class="editor-row">
            <div class="editor-label">Direction:</div>
            <div class="editor-value">
                <input type="range" id="directionValue" min="0" max="360" value="0">
            </div>
        </div>
        
        <div class="editor-buttons">
            <button class="editor-btn drag" id="dragPlanetBtn">Drag Planet</button>
            <button class="editor-btn" id="applyChangesBtn">Apply</button>
            <button class="editor-btn cancel" id="exitEditorBtn">Exit</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('spaceCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Physics constants
        const G = 6.674 * 10e-2; // Gravitational constant (scaled for simulation)
        const MIN_PLANET_RADIUS = 5;
        const MAX_PLANET_RADIUS = 100;
        const DENSITY = 1; // Density factor for mass calculation
        const RESTITUTION = 0.8; // Coefficient of restitution (elasticity of collisions)
        const INFLUENCE_THRESHOLD = 300; // Distance threshold to consider gravitational influence 
        const SIZE_RATIO_THRESHOLD = 0.625; // Threshold for similar sized planets (5/8 or 62.5%)
        const DEBRIS_COUNT = 13; // Number of debris particles to create on collision
        const SIZE_REDUCTION = 0.8; // How much planets shrink after collision (80% of original)

        // Seed control
        const DEFAULT_SEED = 12345; // Default starting seed
        let currentSeed = DEFAULT_SEED;
        let seededRandom = null;

        
        // Simulation settings
        const SIMULATION_STEPS = 2000; // Number of steps to simulate
        const SIMULATION_DT = 0.5; // Time step for simulations

        // Time control
        let timeScale = 32.0;
        let isPaused = false;
        let previousTimeScale = timeScale;
        
        // Pause Menu
        const pauseOverlay = document.getElementById('pauseOverlay');
        const pauseIndicator = document.getElementById('pauseIndicator');
        const resumeBtn = document.getElementById('resumeBtn');
        const resetKeysBtn = document.getElementById('resetKeysBtn');
        const keybindItems = document.querySelectorAll('.keybind-item');
        let currentListeningElement = null;
        
        // Keybindings
        let keybindings = {
            createPlanet: 'n',
            deletePlanet: 'd',
            editPlanet: 'e',
            simulatePaths: 'q',
            togglePause: 'p',
            resetCamera: 'r'
        };
        
        // Load keybindings from localStorage if available
        function loadKeybindings() {
            const savedBindings = localStorage.getItem('spaceSimKeybindings');
            if (savedBindings) {
                try {
                    keybindings = JSON.parse(savedBindings);
                    updateKeybindDisplay();
                } catch (e) {
                    console.error('Error loading keybindings:', e);
                }
            }
        }


function initSeededRandom(seed) {
    currentSeed = seed;
    // Simple seeded random generator (Mulberry32 algorithm)
    seededRandom = function() {
        let t = currentSeed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function generateSaveCode() {
    const state = {
        seed: currentSeed,
        planets: planets.map(p => ({
            x: p.x,
            y: p.y,
            radius: p.radius,
            vx: p.vx,
            vy: p.vy,
            color: p.color,
            massMultiplier: p.massMultiplier
        })),
        camera: { x: cameraX, y: cameraY, zoom: zoomLevel },
        timeScale: timeScale
    };
    return btoa(JSON.stringify(state));
}

function loadFromSaveCode(code) {
    try {
        const state = JSON.parse(atob(code));
        initSeededRandom(state.seed);
        
        // Clear existing planets
        planets = [];
        debris = [];
        
        // Create new planets from save
        state.planets.forEach(p => {
            const planet = new Planet(p.x, p.y, p.radius);
            planet.vx = p.vx;
            planet.vy = p.vy;
            planet.color = p.color;
            planet.massMultiplier = p.massMultiplier;
            planet.mass = Math.PI * p.radius * p.radius * DENSITY * p.massMultiplier;
            planets.push(planet);
        });
        
        // Restore camera and time
        cameraX = state.camera.x;
        cameraY = state.camera.y;
        zoomLevel = state.camera.zoom;
        timeScale = state.timeScale;
        
        return true;
    } catch (e) {
        console.error("Invalid save code", e);
        return false;
    }
}

function resetSimulation() {
    planets = [];
    debris = [];
    for (let i = 0; i < 5; i++) {
        planets.push(createRandomPlanet());
    }
    resetCamera();
    simulationPaths = [];
}
        
        // Save keybindings to localStorage
        function saveKeybindings() {
            localStorage.setItem('spaceSimKeybindings', JSON.stringify(keybindings));
        }
        
        // Update keybind display
        function updateKeybindDisplay() {
            for (const [action, key] of Object.entries(keybindings)) {
                const keyElement = document.getElementById(`${action}Key`);
                if (keyElement) {
                    keyElement.textContent = key.toUpperCase();
                }
            }
        }
        
        // Reset keybindings to default
        function resetKeybindings() {
            keybindings = {
                createPlanet: 'n',
                deletePlanet: 'd',
                editPlanet: 'e',
                simulatePaths: 'q',
                togglePause: 'p',
                resetCamera: 'r',
                showSeed: 'l',
                inputSeed: 'i'
            };
            updateKeybindDisplay();
            saveKeybindings();
        }
        
        // Toggle pause state
        function togglePause() {
            isPaused = !isPaused;
            
            if (isPaused) {
                previousTimeScale = timeScale;
                timeScale = 0;
                pauseOverlay.classList.add('active');
                pauseIndicator.classList.add('active');
            } else {
                timeScale = previousTimeScale;
                pauseOverlay.classList.remove('active');
                pauseIndicator.classList.remove('active');
                
                // If we were listening for a key, cancel it
                if (currentListeningElement) {
                    currentListeningElement.classList.remove('listening');
                    currentListeningElement = null;
                }
            }
        }
        
        // Setup pause menu event listeners
        resumeBtn.addEventListener('click', togglePause);
        
        resetKeysBtn.addEventListener('click', resetKeybindings);
        
        // Setup keybind customization
        keybindItems.forEach(item => {
            item.addEventListener('click', function() {
                const action = this.getAttribute('data-action');
                const keyElement = this.querySelector('.keybind-key');
                
                // Cancel any current listening
                if (currentListeningElement) {
                    currentListeningElement.classList.remove('listening');
                }
                
                // Set this element as listening
                this.classList.add('listening');
                currentListeningElement = this;
                keyElement.textContent = '...';
                
                // Create one-time event listener for the next keypress
                const handleKeyPress = function(e) {
                    e.preventDefault();
                    
                    // Get the key (lowercase for consistency)
                    let newKey = e.key.toLowerCase();
                    
                    // Special case for Escape key
                    if (newKey === 'escape') {
                        // Cancel rebinding
                        keyElement.textContent = keybindings[action].toUpperCase();
                        item.classList.remove('listening');
                        currentListeningElement = null;
                        document.removeEventListener('keydown', handleKeyPress);
                        return;
                    }
                    
                    // For special keys, use more readable names
                    if (newKey === ' ') newKey = 'space';
                    
                    // Update the keybinding
                    keybindings[action] = newKey;
                    keyElement.textContent = newKey.toUpperCase();
                    
                    // Save keybindings
                    saveKeybindings();
                    
                    // Reset listening state
                    item.classList.remove('listening');
                    currentListeningElement = null;
                    
                    // Remove this temporary event listener
                    document.removeEventListener('keydown', handleKeyPress);
                };
                
                document.addEventListener('keydown', handleKeyPress);
            });
        let debris = [];
        });
        
        // Simulation control
        let isSimulating = false;
        let simulationPaths = [];
        const simulationInfo = document.getElementById('simulationInfo');
        const simulationProgress = document.getElementById('simulationProgress');
        
        // Camera/view controls
        let cameraX = 0;
        let cameraY = 0;
        let zoomLevel = 1;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Mouse tracking
        let mouseX = 0;
        let mouseY = 0;
        let hoveredPlanet = null;
        let selectedPlanet = null;

        // Editor mode controls
        let isEditorOpen = false;
        let isEditorDragging = false;
        
        // Array to store planets and debris
        let planets = [];
        let debris = [];

        // Get editor elements
        const planetEditor = document.getElementById('planetEditor');
        const planetSize = document.getElementById('planetSize');
        const planetMass = document.getElementById('planetMass');
        const planetColor = document.getElementById('planetColor');
        const speedValue = document.getElementById('speedValue');
        const directionValue = document.getElementById('directionValue');
        const dragPlanetBtn = document.getElementById('dragPlanetBtn');
        const applyChangesBtn = document.getElementById('applyChangesBtn');
        const exitEditorBtn = document.getElementById('exitEditorBtn');
        const velocityArrow = document.getElementById('velocityArrow');
        const velocityPlanet = document.getElementById('velocityPlanet');

        // Set up time control buttons
        const timeButtons = document.querySelectorAll('.time-btn');
        timeButtons.forEach(btn => {
            btn.addEventListener('click', function() {
                if (isPaused) return; // Don't change time scale if paused
                
                // Update active state
                timeButtons.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Set time scale
                timeScale = parseFloat(this.getAttribute('data-speed'));
                previousTimeScale = timeScale;
            });
        });

        // Color palette for planets
        const planetColors = [
            '#FF5733', '#C70039', '#900C3F', '#581845',
            '#FFC300', '#DAF7A6', '#FF5733', '#2471A3',
            '#1ABC9C', '#3498DB', '#E74C3C', '#8E44AD'
        ];

        // Pre-generate star data for better performance
        const starCache = new Map();
        const starDensity = 0.00002; // Significantly reduced star density
        const gridSize = 1000; // Larger grid size to further reduce stars

        // Planet Editor Functions
        function openPlanetEditor(planet) {
            if (isEditorOpen) return;

            // Pause the simulation
            previousTimeScale = timeScale;
            timeScale = 0;
            isPaused = true;
            isEditorOpen = true;
            selectedPlanet = planet;
            
            // Show paused indicator
            pauseIndicator.classList.add('active');
            
            // Set editor values
            planetSize.value = planet.radius;
            planetMass.value = planet.massMultiplier || 1;
            planetColor.value = planet.color;
            
            // Calculate speed and direction
            const speed = Math.sqrt(planet.vx * planet.vx + planet.vy * planet.vy);
            speedValue.value = speed.toFixed(1);
            
            // Calculate direction angle in degrees
            let direction = Math.atan2(planet.vy, planet.vx) * 180 / Math.PI;
            if (direction < 0) direction += 360;
            directionValue.value = direction.toFixed(0);
            
            // Update velocity arrow visualization
            updateVelocityArrow();
            
            // Set planet color in the velocity visualizer
            velocityPlanet.style.backgroundColor = planet.color;
            
            // Show the editor
            planetEditor.style.display = 'block';
        }
        
        function closePlanetEditor() {
            if (!isEditorOpen) return;

            // Restore time scale
            timeScale = previousTimeScale;
            isPaused = false;
            isEditorOpen = false;
            isEditorDragging = false;
            selectedPlanet = null;
            dragPlanetBtn.classList.remove('active');
            
            // Hide paused indicator
            pauseIndicator.classList.remove('active');
            
            // Hide the editor
            planetEditor.style.display = 'none';
        }
        
        function applyEditorChanges() {
            if (!selectedPlanet) return;
            
            // Apply size change
            selectedPlanet.radius = parseFloat(planetSize.value);
            
            // Apply mass multiplier (storing it separately)
            selectedPlanet.massMultiplier = parseFloat(planetMass.value);
            selectedPlanet.mass = Math.PI * selectedPlanet.radius * selectedPlanet.radius * 
                                 DENSITY * selectedPlanet.massMultiplier;
            
            // Apply color change
            selectedPlanet.color = planetColor.value;
            
            // Apply velocity changes
            const speed = parseFloat(speedValue.value);
            const direction = parseFloat(directionValue.value) * Math.PI / 180;
            selectedPlanet.vx = speed * Math.cos(direction);
            selectedPlanet.vy = speed * Math.sin(direction);
            
            // Clear the trail after editing
            selectedPlanet.trail = [];
            
            // Clear simulation paths when editing planets
            simulationPaths = [];
        }
        
        function updateVelocityArrow() {
            if (!selectedPlanet) return;
            
            const speed = parseFloat(speedValue.value);
            const direction = parseFloat(directionValue.value) * Math.PI / 180;
            
            // Scale the arrow length based on speed (max 40px)
            const maxLength = 40;
            const arrowLength = Math.min(speed * 10, maxLength);
            
            // Set the arrow position and rotation
            velocityArrow.style.width = arrowLength + 'px';
            velocityArrow.style.transform = `rotate(${directionValue.value}deg)`;
            velocityArrow.style.borderLeftWidth = `${arrowLength}px`;
            velocityArrow.style.borderLeftColor = selectedPlanet.color;
        }
        
        function resetCamera() {
            cameraX = 0;
            cameraY = 0;
            zoomLevel = 1;
        }
        
        // Set up editor event listeners
        planetSize.addEventListener('input', function() {
            if (!selectedPlanet) return;
            applyEditorChanges();
        });
        
        planetMass.addEventListener('input', function() {
            if (!selectedPlanet) return;
            applyEditorChanges();
        });
        
        planetColor.addEventListener('input', function() {
            if (!selectedPlanet) return;
            applyEditorChanges();
            velocityPlanet.style.backgroundColor = planetColor.value;
            velocityArrow.style.borderLeftColor = planetColor.value;
        });
        
        speedValue.addEventListener('input', function() {
            if (!selectedPlanet) return;
            updateVelocityArrow();
            applyEditorChanges();
        });
        
        directionValue.addEventListener('input', function() {
            if (!selectedPlanet) return;
            updateVelocityArrow();
            applyEditorChanges();
        });
        
        dragPlanetBtn.addEventListener('click', function() {
            isEditorDragging = !isEditorDragging;
            this.classList.toggle('active');
        });
        
        applyChangesBtn.addEventListener('click', function() {
            applyEditorChanges();
        });
        
        exitEditorBtn.addEventListener('click', function() {
            closePlanetEditor();
        });

        // Convert screen to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - canvas.width/2) / zoomLevel + cameraX,
                y: (screenY - canvas.height/2) / zoomLevel + cameraY
            };
        }

        // Convert world to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - cameraX) * zoomLevel + canvas.width/2,
                y: (worldY - cameraY) * zoomLevel + canvas.height/2
            };
        }

        // Check if a new planet would be influenced by existing planets
        function hasNearbyInfluence(x, y) {
            for (let planet of planets) {
                const dx = planet.x - x;
                const dy = planet.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < INFLUENCE_THRESHOLD) {
                    return true;
                }
            }
            return false;
        }

        // Debris class for collision effects
        class Debris {
            constructor(x, y, vx, vy, color, size, lifetime) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.maxLifetime = lifetime;
                this.lifetime = lifetime;
                this.alpha = 1;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.lifetime -= dt;
                this.alpha = this.lifetime / this.maxLifetime;
                return this.lifetime > 0;
            }

            draw(ctx) {
                const screenPos = worldToScreen(this.x, this.y);
                const screenSize = this.size * zoomLevel;
                
                // Skip if off-screen
                if (screenPos.x + screenSize < 0 || 
                    screenPos.x - screenSize > canvas.width ||
                    screenPos.y + screenSize < 0 || 
                    screenPos.y - screenSize > canvas.height) {
                    return;
                }

                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace(')', `, ${this.alpha})`).replace('rgb', 'rgba');
                ctx.fill();
            }
        }

        // Planet class with improved collision handling
            class Planet {
                constructor(x, y, radius) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.massMultiplier = 1; 
                    this.mass = Math.PI * radius * radius * DENSITY * this.massMultiplier;
                    
                    if (hasNearbyInfluence(x, y)) {
                        this.vx = (seededRandom() - 0.5) * 1;
                        this.vy = (seededRandom() - 0.5) * 1;
                    } else {
                        this.vx = 0;
                        this.vy = 0;
                    }
                    
                    // Use seeded random for color selection
                    this.color = planetColors[Math.floor(seededRandom() * planetColors.length)];
                    this.trail = [];
                    this.maxTrailLength = 50;
                }

            clone() {
                const clone = new Planet(this.x, this.y, this.radius);
                clone.vx = this.vx;
                clone.vy = this.vy;
                clone.mass = this.mass;
                clone.massMultiplier = this.massMultiplier;
                clone.color = this.color;
                return clone;
            }

            update(planets, dt) {
                // Add current position to trail (reduced frequency at higher time scales)
                if (Math.random() < 1/Math.max(1, dt*2)) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }

                // Apply forces from other planets
                for (let planet of planets) {
                    if (planet === this) continue;
                    
                    // Calculate distance
                    const dx = planet.x - this.x;
                    const dy = planet.y - this.y;
                    const distanceSquared = dx * dx + dy * dy;
                    const distance = Math.sqrt(distanceSquared);
                    
                    // Skip gravitational calculation if planets are colliding
                    if (distance < this.radius + planet.radius) {
                        continue;
                    }
                    
                    // Calculate gravitational force (F = G * m1 * m2 / r^2)
                    const force = G * this.mass * planet.mass / distanceSquared;
                    const angle = Math.atan2(dy, dx);
                    
                    // Apply acceleration (F = ma, so a = F/m) with time scaling
                    const ax = force * Math.cos(angle) / this.mass;
                    const ay = force * Math.sin(angle) / this.mass;
                    
                    this.vx += ax * dt;
                    this.vy += ay * dt;
                }

                // Update position based on velocity (no slowdown in space) with time scaling
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }

            draw(ctx) {
                // Convert planet coordinates to screen coordinates
                const screenPos = worldToScreen(this.x, this.y);
                const screenRadius = this.radius * zoomLevel;
                
                // Skip drawing if planet is off-screen (with buffer)
                if (screenPos.x + screenRadius < 0 || 
                    screenPos.x - screenRadius > canvas.width ||
                    screenPos.y + screenRadius < 0 || 
                    screenPos.y - screenRadius > canvas.height) {
                    return;
                }

                // Draw trail
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    const firstPoint = worldToScreen(this.trail[0].x, this.trail[0].y);
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        const point = worldToScreen(this.trail[i].x, this.trail[i].y);
                        ctx.lineTo(point.x, point.y);
                    }
                    
                    ctx.strokeStyle = `rgba(${parseInt(this.color.slice(1, 3), 16)}, 
                                          ${parseInt(this.color.slice(3, 5), 16)}, 
                                          ${parseInt(this.color.slice(5, 7), 16)}, 
                                          0.5)`;
                    ctx.lineWidth = 2 * zoomLevel;
                    ctx.stroke();
                }

                // Draw planet
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                
                // Add gradient for more realistic look
                const gradient = ctx.createRadialGradient(
                    screenPos.x - screenRadius/3, screenPos.y - screenRadius/3, 0,
                    screenPos.x, screenPos.y, screenRadius
                );
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(0.3, this.color);
                gradient.addColorStop(1, `rgb(${parseInt(this.color.slice(1, 3), 16) / 2}, 
                                           ${parseInt(this.color.slice(3, 5), 16) / 2}, 
                                           ${parseInt(this.color.slice(5, 7), 16) / 2})`);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Highlight when hovered or selected
                if (this === hoveredPlanet || this === selectedPlanet) {
                    ctx.strokeStyle = this === selectedPlanet ? '#00ffff' : 'white';
                    ctx.lineWidth = (this === selectedPlanet ? 3 : 2) * zoomLevel;
                    ctx.stroke();
                }
                
                // Show velocity vector if selected
                if (this === selectedPlanet) {
                    const velocityScale = 10; // Scale factor for better visibility
                    const endX = screenPos.x + this.vx * velocityScale;
                    const endY = screenPos.y + this.vy * velocityScale;
                    
                    // Draw velocity line
                    ctx.beginPath();
                    ctx.moveTo(screenPos.x, screenPos.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2 * zoomLevel;
                    ctx.stroke();
                    
                    // Draw arrowhead
                    const arrowSize = 8 * zoomLevel;
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle - Math.PI/6),
                        endY - arrowSize * Math.sin(angle - Math.PI/6)
                    );
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle + Math.PI/6),
                        endY - arrowSize * Math.sin(angle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = '#00ffff';
                    ctx.fill();
                }
            }

            isPointInside(worldX, worldY) {
                const dx = this.x - worldX;
                const dy = this.y - worldY;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        // Create explosion debris
        function createExplosionDebris(x, y, vx, vy, color, radius) {
            for (let i = 0; i < DEBRIS_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const debrisVx = vx/2 + Math.cos(angle) * speed;
                const debrisVy = vy/2 + Math.sin(angle) * speed;
                const size = radius * (0.1 + Math.random() * 0.2);
                const lifetime = 30 + Math.floor(Math.random() * 60);
                
                // Convert hex color to rgba for the debris
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                const rgbaColor = `rgb(${r}, ${g}, ${b})`;
                
                debris.push(new Debris(x, y, debrisVx, debrisVy, rgbaColor, size, lifetime));
            }
        }

        function handleCollisions(dt, simulationPlanets = null) {
            const planetsArray = simulationPlanets || planets;
            const planetsToRemove = [];
            
            for (let i = 0; i < planetsArray.length; i++) {
                for (let j = i + 1; j < planetsArray.length; j++) {
                    const planet1 = planetsArray[i];
                    const planet2 = planetsArray[j];
                    
                    // Skip if either planet is already marked for removal
                    if (planetsToRemove.includes(planet1) || planetsToRemove.includes(planet2)) {
                        continue;
                    }
                    
                    // Calculate distance between planets
                    const dx = planet2.x - planet1.x;
                    const dy = planet2.y - planet1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = planet1.radius + planet2.radius;
                    
                    // Check for collision
                    if (distance < minDistance) {
                        // Calculate size ratio to determine collision type
                        const sizeRatio = Math.min(planet1.radius, planet2.radius) / 
                                        Math.max(planet1.radius, planet2.radius);
                        
                        // Normalized collision vector
                        const nx = dx / distance;
                        const ny = dy / distance;
                        
                        // Relative velocity
                        const relativeVelocityX = planet2.vx - planet1.vx;
                        const relativeVelocityY = planet2.vy - planet1.vy;
                        
                        // Relative velocity along collision normal
                        const relativeVelocityAlongNormal = relativeVelocityX * nx + relativeVelocityY * ny;
                        
                        // Do not resolve if velocities are separating
                        if (relativeVelocityAlongNormal > 0) continue;
                        
                        // Calculate impulse scalar
                        const restitution = RESTITUTION;
                        const j = -(1 + restitution) * relativeVelocityAlongNormal;
                        const impulse = j / (1/planet1.mass + 1/planet2.mass);
                        
                        // Apply impulse
                        const impulseX = impulse * nx;
                        const impulseY = impulse * ny;
                        
                        // Save original velocities for debris
                        const p1vx = planet1.vx;
                        const p1vy = planet1.vy;
                        const p2vx = planet2.vx;
                        const p2vy = planet2.vy;
                        
                        // Update velocities
                        planet1.vx -= impulseX / planet1.mass;
                        planet1.vy -= impulseY / planet1.mass;
                        planet2.vx += impulseX / planet2.mass;
                        planet2.vy += impulseY / planet2.mass;
                        
                        // Move planets apart to prevent sticking
                        const overlap = (minDistance - distance) * 0.5;
                        planet1.x -= overlap * nx;
                        planet1.y -= overlap * ny;
                        planet2.x += overlap * nx;
                        planet2.y += overlap * ny;
                        
                        // Handle different collision types based on size ratio
                        if (sizeRatio >= SIZE_RATIO_THRESHOLD) {
                            // Similar-sized planets: both shrink
                            planet1.radius *= SIZE_REDUCTION;
                            planet2.radius *= SIZE_REDUCTION;
                            
                            // Recalculate masses
                            planet1.mass = Math.PI * planet1.radius * planet1.radius * DENSITY * planet1.massMultiplier;
                            planet2.mass = Math.PI * planet2.radius * planet2.radius * DENSITY * planet2.massMultiplier;
                            
                            // Create explosion debris (only in real simulation)
                            if (!simulationPlanets) {
                                const collisionX = (planet1.x + planet2.x) / 2;
                                const collisionY = (planet1.y + planet2.y) / 2;
                                createExplosionDebris(collisionX, collisionY, 
                                                    (p1vx + p2vx)/2, (p1vy + p2vy)/2,
                                                    planet1.color, Math.min(planet1.radius, planet2.radius));
                            }
                            
                            // Remove if too small
                            if (planet1.radius < MIN_PLANET_RADIUS / 2) {
                                planetsToRemove.push(planet1);
                                if (!simulationPlanets) {
                                    createExplosionDebris(planet1.x, planet1.y, p1vx, p1vy, planet1.color, planet1.radius);
                                }
                            }
                            if (planet2.radius < MIN_PLANET_RADIUS / 2) {
                                planetsToRemove.push(planet2);
                                if (!simulationPlanets) {
                                    createExplosionDebris(planet2.x, planet2.y, p2vx, p2vy, planet2.color, planet2.radius);
                                }
                            }
                        } else {
                            // Different-sized planets: smaller one is destroyed
                            const smallerPlanet = planet1.radius < planet2.radius ? planet1 : planet2;
                            const largerPlanet = planet1.radius < planet2.radius ? planet2 : planet1;
                            
                            // Create debris for smaller planet
                            if (!simulationPlanets) {
                                createExplosionDebris(smallerPlanet.x, smallerPlanet.y, 
                                                    smallerPlanet.vx, smallerPlanet.vy,
                                                    smallerPlanet.color, smallerPlanet.radius);
                            }
                            
                            planetsToRemove.push(smallerPlanet);
                        }
                    }
                }
            }
            
            // Remove planets marked for deletion
            if (planetsToRemove.length > 0) {
                if (simulationPlanets) {
                    return planetsArray.filter(planet => !planetsToRemove.includes(planet));
                } else {
                    planets = planets.filter(planet => !planetsToRemove.includes(planet));
                }
            }
            
            return simulationPlanets || planets;
        }

       // Improved path simulation with proper collision physics
    async function simulatePaths() {
        if (isSimulating || planets.length === 0 || isEditorOpen || isPaused) return;
        
        isSimulating = true;
        simulationInfo.style.display = 'block';
        
        // Clone current planets for simulation
        let simulationPlanets = planets.map(planet => planet.clone());
        simulationPaths = planets.map(() => []);
        
        // Store initial positions
        for (let j = 0; j < simulationPlanets.length; j++) {
            simulationPaths[j].push({
                x: simulationPlanets[j].x,
                y: simulationPlanets[j].y
            });
        }

        const chunkSize = 20;
        const totalSteps = SIMULATION_STEPS;
        
        for (let step = 0; step < totalSteps; step += chunkSize) {
            // Update progress indicator
            const progress = Math.floor((step / totalSteps) * 100);
            simulationProgress.textContent = `${progress}%`;
            
            // Run a chunk of simulation steps with better physics
            for (let i = 0; i < chunkSize && step + i < totalSteps; i++) {
                // Update planet positions with proper physics
                for (let planet of simulationPlanets) {
                    // Reset acceleration each frame
                    planet.ax = 0;
                    planet.ay = 0;
                    
                    // Calculate gravitational forces from all other planets
                    for (let other of simulationPlanets) {
                        if (planet === other) continue;
                        
                        const dx = other.x - planet.x;
                        const dy = other.y - planet.y;
                        const distanceSq = dx * dx + dy * dy;
                        const distance = Math.sqrt(distanceSq);
                        
                        // Only apply gravity if not colliding
                        if (distance > planet.radius + other.radius) {
                            const force = G * planet.mass * other.mass / distanceSq;
                            const angle = Math.atan2(dy, dx);
                            
                            planet.ax += force * Math.cos(angle) / planet.mass;
                            planet.ay += force * Math.sin(angle) / planet.mass;
                        }
                    }
                    
                    // Update velocity (half-step)
                    planet.vx += planet.ax * SIMULATION_DT * 0.5;
                    planet.vy += planet.ay * SIMULATION_DT * 0.5;
                    
                    // Update position
                    planet.x += planet.vx * SIMULATION_DT;
                    planet.y += planet.vy * SIMULATION_DT;
                    
                    // Update velocity (second half-step)
                    planet.vx += planet.ax * SIMULATION_DT * 0.5;
                    planet.vy += planet.ay * SIMULATION_DT * 0.5;
                }
                
                // Handle collisions with proper physics
                simulationPlanets = handleCollisions(SIMULATION_DT, simulationPlanets);
                
                // Store positions after physics update
                for (let j = 0; j < simulationPlanets.length; j++) {
                    simulationPaths[j].push({
                        x: simulationPlanets[j].x,
                        y: simulationPlanets[j].y
                    });
                }
                
                // If no planets left, end simulation
                if (simulationPlanets.length === 0) break;
            }
            
            // Allow UI to update
            await new Promise(resolve => setTimeout(resolve, 0));
            
            // If no planets left, end simulation
            if (simulationPlanets.length === 0) break;
        }
        
        // Finalize progress
        simulationProgress.textContent = "100%";
        
        // Hide info panel after a short delay
        setTimeout(() => {
            simulationInfo.style.display = 'none';
            isSimulating = false;
        }, 1000);
    }


        // Create initial planets
function createRandomPlanet() {
    const radius = MIN_PLANET_RADIUS + seededRandom() * (MAX_PLANET_RADIUS - MIN_PLANET_RADIUS);
    const x = (seededRandom() - 0.5) * canvas.width;
    const y = (seededRandom() - 0.5) * canvas.height;
    return new Planet(x, y, radius);
}

        // Initialize the random generator at startup
        initSeededRandom(DEFAULT_SEED);
        
        // Initialize with a few planets
        resetSimulation();

        // Handle window resize
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Track mouse position
        canvas.addEventListener('mousemove', function(event) {
            mouseX = event.clientX;
            mouseY = event.clientY;
            const worldCoords = screenToWorld(mouseX, mouseY);
            
            // If in editor dragging mode, update planet position
            if (isEditorOpen && isEditorDragging && selectedPlanet) {
                selectedPlanet.x = worldCoords.x;
                selectedPlanet.y = worldCoords.y;
                selectedPlanet.trail = []; // Clear trail when dragging
                return;
            }
            
            // Update camera if dragging
            if (isDragging) {
                const dx = (mouseX - lastMouseX) / zoomLevel;
                const dy = (mouseY - lastMouseY) / zoomLevel;
                cameraX -= dx;
                cameraY -= dy;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }
            
            // Check for hovered planet
            hoveredPlanet = null;
            for (let planet of planets) {
                if (planet.isPointInside(worldCoords.x, worldCoords.y)) {
                    hoveredPlanet = planet;
                    break;
                }
            }
        });

        // Handle mouse down for dragging or selecting
        canvas.addEventListener('mousedown', function(event) {
            // If we're in editor dragging mode, handle drag interaction
            if (isEditorOpen && isEditorDragging && selectedPlanet) {
                return; // Already handling dragging in mousemove
            }
            
            // If clicking on a planet, select it
            if (hoveredPlanet) {
                selectedPlanet = hoveredPlanet;
                
                // Check for double-click to open editor
                if (event.detail === 2) {
                    openPlanetEditor(selectedPlanet);
                }
                
                return;
            }
            
            // Otherwise start camera dragging
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            canvas.style.cursor = 'grabbing';
            
            // Clear selection if clicking on space
            selectedPlanet = null;
        });

        // Handle mouse up for dragging
        window.addEventListener('mouseup', function() {
            isDragging = false;
            canvas.style.cursor = 'default';
        });

        // Handle zoom with mouse wheel
        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // Get mouse position in world coordinates before zoom
            const mouseWorldBefore = screenToWorld(mouseX, mouseY);
            
            // Apply zoom factor
            const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
            zoomLevel *= zoomFactor;
            
            // Limit zoom level (increased max zoom out)
            zoomLevel = Math.max(0.01, Math.min(zoomLevel, 10));
            
            // Get mouse position in world coordinates after zoom
            const mouseWorldAfter = screenToWorld(mouseX, mouseY);
            
            // Adjust camera to keep mouse position fixed over same world position
            cameraX += (mouseWorldBefore.x - mouseWorldAfter.x);
            cameraY += (mouseWorldBefore.y - mouseWorldAfter.y);
        });

        // Handle key presses with custom keybindings
        document.addEventListener('keydown', function(event) {
            const key = event.key.toLowerCase();
            
            // Ignore key events when in editor mode (except Escape)
            if (isEditorOpen && key !== 'escape') return;
            
            // Escape key to close editor
            if (key === 'escape' && isEditorOpen) {
                closePlanetEditor();
                return;
            }
            
            // Check for pause toggle
            if (key === keybindings.togglePause) {
                togglePause();
                return;
            }
            
            // If paused and not in editor mode, only allow resume
            if (isPaused && !isEditorOpen) return;
            
            // Create new planet
            if (key === keybindings.createPlanet) {
                const worldCoords = screenToWorld(mouseX, mouseY);
                const radius = MIN_PLANET_RADIUS + Math.random() * (MAX_PLANET_RADIUS - MIN_PLANET_RADIUS);
                planets.push(new Planet(worldCoords.x, worldCoords.y, radius));
                
                // Clear simulation paths when adding new planets
                simulationPaths = [];
            }
            
            // Delete hovered planet
            if (key === keybindings.deletePlanet && hoveredPlanet) {
                // Create explosion debris when manually deleting
                createExplosionDebris(hoveredPlanet.x, hoveredPlanet.y, 
                                    hoveredPlanet.vx, hoveredPlanet.vy,
                                    hoveredPlanet.color, hoveredPlanet.radius);
                
                planets = planets.filter(planet => planet !== hoveredPlanet);
                hoveredPlanet = null;
                
                // Clear simulation paths when removing planets
                simulationPaths = [];
            }
            
            // Simulate planet paths
            if (key === keybindings.simulatePaths) {
                simulatePaths();
            }
            
            // Edit selected planet
            if (key === keybindings.editPlanet && hoveredPlanet) {
                openPlanetEditor(hoveredPlanet);
            }

                // Show current seed
    if (key === keybindings.showSeed) {
        const saveCode = generateSaveCode();
        alert(`Current seed: ${currentSeed}\nSave code:\n${saveCode}`);
        return;
    }
    
    // Input new seed
    if (key === keybindings.inputSeed) {
        const input = prompt("Enter seed number or save code:");
        if (input) {
            if (/^\d+$/.test(input)) {
                // Numeric seed
                initSeededRandom(parseInt(input));
                resetSimulation();
            } else {
                // Try to parse as save code
                if (!loadFromSaveCode(input)) {
                    alert("Invalid save code!");
                }
            }
        }
        return;
    }
});
            
            // Reset camera
            if (key === keybindings.resetCamera) {
                resetCamera();
            }
        });

        // Seeded random function for star generation
        function seededRandom(x, y) {
            const seed = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return seed - Math.floor(seed);
        }

        // Generate star data for a grid cell and cache it
        function generateStarsForCell(cellX, cellY) {
            const cellKey = `${cellX},${cellY}`;
            
            if (starCache.has(cellKey)) {
                return starCache.get(cellKey);
            }
            
            const stars = [];
            // Determine number of stars in this cell based on density - much less than before
            const numStars = Math.floor(gridSize * gridSize * starDensity);
            
            for (let i = 0; i < numStars; i++) {
                // Deterministic star position based on cell and index
                const x = cellX * gridSize + gridSize * seededRandom(cellX, i);
                const y = cellY * gridSize + gridSize * seededRandom(i, cellY);
                
                // Vary star size slightly
                const size = 1.5 * (0.5 + seededRandom(x, y));
                
                // Vary star brightness
                const alpha = 0.5 + 0.5 * seededRandom(y, x);
                
                stars.push({x, y, size, alpha});
            }
            
            starCache.set(cellKey, stars);
            return stars;
        }

        // Draw stars background that moves with camera - optimized
        function drawStars() {
            // Calculate visible grid cells with more restrictive bounds
            const visibleWidth = canvas.width / zoomLevel;
            const visibleHeight = canvas.height / zoomLevel;
            
            const startCellX = Math.floor((cameraX - visibleWidth/2) / gridSize);
            const endCellX = Math.ceil((cameraX + visibleWidth/2) / gridSize);
            const startCellY = Math.floor((cameraY - visibleHeight/2) / gridSize);
            const endCellY = Math.ceil((cameraY + visibleHeight/2) / gridSize);
            
            // Apply throttling when zoomed out far
            const skipFactor = Math.max(1, Math.floor(10 / zoomLevel));
            
            // Generate stars for visible grid cells
            for (let cellX = startCellX; cellX <= endCellX; cellX++) {
                for (let cellY = startCellY; cellY <= endCellY; cellY++) {
                    // Skip cells based on zoom level for performance
                    if ((cellX + cellY) % skipFactor !== 0 && zoomLevel < 0.2) continue;
                    
                    const stars = generateStarsForCell(cellX, cellY);
                    
                    // Draw stars from this cell
                    for (const star of stars) {
                        // Map to screen coordinates
                        const screenPos = worldToScreen(star.x, star.y);
                        
                        // Only draw if on screen
                        if (screenPos.x >= 0 && screenPos.x <= canvas.width &&
                            screenPos.y >= 0 && screenPos.y <= canvas.height) {
                            
                            // Draw star
                            ctx.beginPath();
                            ctx.arc(screenPos.x, screenPos.y, star.size * zoomLevel, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // Draw simulated paths
        function drawSimulationPaths() {
            if (simulationPaths.length === 0 || simulationPaths[0].length === 0) return;
            
            // Draw paths for each planet
            for (let i = 0; i < Math.min(planets.length, simulationPaths.length); i++) {
                const planet = planets[i];
                const path = simulationPaths[i];
                
                if (path.length < 2) continue;
                
                ctx.beginPath();
                
                // Start at the current planet position
                const startPos = worldToScreen(planet.x, planet.y);
                ctx.moveTo(startPos.x, startPos.y);
                
                // Draw dotted line for the predicted path
                ctx.setLineDash([5, 5]);
                
                // Draw the path with gradient opacity
                for (let j = 0; j < path.length; j++) {
                    const point = worldToScreen(path[j].x, path[j].y);
                    ctx.lineTo(point.x, point.y);
                }
                
                // Path color based on planet with reduced opacity
                const r = parseInt(planet.color.slice(1, 3), 16);
                const g = parseInt(planet.color.slice(3, 5), 16);
                const b = parseInt(planet.color.slice(5, 7), 16);
                
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 1.5 * zoomLevel;
                ctx.stroke();
                
                // Reset line dash
                ctx.setLineDash([]);
            }
        }

        // Animation variables
        let lastTime = 0;

        // Animation loop with time control
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Calculate delta time (in seconds)
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // Cap dt at 0.1s to prevent huge jumps
            lastTime = currentTime;
            
            // Apply time scale to delta time
            const dt = deltaTime * timeScale;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars in background
            drawStars();
            
            // Draw simulation paths if available
            drawSimulationPaths();
            
            // Skip physics updates if simulating or paused
            if (!isSimulating && !isPaused) {
                // Handle collisions
                handleCollisions(dt);
                
                // Update and draw planets
                for (let planet of planets) {
                    planet.update(planets, dt);
                    planet.draw(ctx);
                }
                
                // Update and draw debris
                debris = debris.filter(particle => {
                    const alive = particle.update(dt);
                    if (alive) {
                        particle.draw(ctx);
                    }
                    return alive;
                });
            } else {
                // Just draw planets without updating
                for (let planet of planets) {
                    planet.draw(ctx);
                }
                
                // Draw debris without updating in paused mode
                for (let particle of debris) {
                    particle.draw(ctx);
                }
            }
        }

        // Load keybindings and start animation
        loadKeybindings();
        animate(0);
    </script>
</body>
</html>
